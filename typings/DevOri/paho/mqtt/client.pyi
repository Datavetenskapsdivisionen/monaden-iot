"""
This type stub file was generated by pyright.
"""

import logging
import platform
import socket
import ssl
from typing import Any, Callable, Dict, Iterator, List, Literal, NamedTuple, Protocol, TYPE_CHECKING, Tuple, TypedDict, Union
from .enums import CallbackAPIVersion, ConnackCode, MQTTErrorCode, MQTTProtocolVersion
from .properties import Properties
from .reasoncodes import ReasonCode, ReasonCodes
from .subscribeoptions import SubscribeOptions

"""
This is an MQTT client module. MQTT is a lightweight pub/sub messaging
protocol that is easy to implement and suitable for low powered devices.
"""
if TYPE_CHECKING:
    class _InPacket(TypedDict):
        command: int
        have_remaining: int
        remaining_count: list[int]
        remaining_mult: int
        remaining_length: int
        packet: bytearray
        to_process: int
        pos: int
        ...
    
    
    class _OutPacket(TypedDict):
        command: int
        mid: int
        qos: int
        pos: int
        to_process: int
        packet: bytes
        info: MQTTMessageInfo | None
        ...
    
    
    class SocketLike(Protocol):
        def recv(self, buffer_size: int) -> bytes:
            ...
        
        def send(self, buffer: bytes) -> int:
            ...
        
        def close(self) -> None:
            ...
        
        def fileno(self) -> int:
            ...
        
        def setblocking(self, flag: bool) -> None:
            ...
        
    
    
time_func = ...
HAVE_DNS = ...
if platform.system() == 'Windows':
    EAGAIN = ...
else:
    EAGAIN = ...
_ = ReasonCodes
CONNECT = ...
CONNACK = ...
PUBLISH = ...
PUBACK = ...
PUBREC = ...
PUBREL = ...
PUBCOMP = ...
SUBSCRIBE = ...
SUBACK = ...
UNSUBSCRIBE = ...
UNSUBACK = ...
PINGREQ = ...
PINGRESP = ...
DISCONNECT = ...
AUTH = ...
MQTT_LOG_INFO = ...
MQTT_LOG_NOTICE = ...
MQTT_LOG_WARNING = ...
MQTT_LOG_ERR = ...
MQTT_LOG_DEBUG = ...
LOGGING_LEVEL = ...
CONNACK_ACCEPTED = ...
CONNACK_REFUSED_PROTOCOL_VERSION = ...
CONNACK_REFUSED_IDENTIFIER_REJECTED = ...
CONNACK_REFUSED_SERVER_UNAVAILABLE = ...
CONNACK_REFUSED_BAD_USERNAME_PASSWORD = ...
CONNACK_REFUSED_NOT_AUTHORIZED = ...
mqtt_ms_invalid = ...
mqtt_ms_publish = ...
mqtt_ms_wait_for_puback = ...
mqtt_ms_wait_for_pubrec = ...
mqtt_ms_resend_pubrel = ...
mqtt_ms_wait_for_pubrel = ...
mqtt_ms_resend_pubcomp = ...
mqtt_ms_wait_for_pubcomp = ...
mqtt_ms_send_pubrec = ...
mqtt_ms_queued = ...
MQTT_ERR_AGAIN = ...
MQTT_ERR_SUCCESS = ...
MQTT_ERR_NOMEM = ...
MQTT_ERR_PROTOCOL = ...
MQTT_ERR_INVAL = ...
MQTT_ERR_NO_CONN = ...
MQTT_ERR_CONN_REFUSED = ...
MQTT_ERR_NOT_FOUND = ...
MQTT_ERR_CONN_LOST = ...
MQTT_ERR_TLS = ...
MQTT_ERR_PAYLOAD_SIZE = ...
MQTT_ERR_NOT_SUPPORTED = ...
MQTT_ERR_AUTH = ...
MQTT_ERR_ACL_DENIED = ...
MQTT_ERR_UNKNOWN = ...
MQTT_ERR_ERRNO = ...
MQTT_ERR_QUEUE_SIZE = ...
MQTT_ERR_KEEPALIVE = ...
MQTTv31 = ...
MQTTv311 = ...
MQTTv5 = ...
MQTT_CLIENT = ...
MQTT_BRIDGE = ...
MQTT_CLEAN_START_FIRST_ONLY: CleanStartOption = ...
sockpair_data = ...
PayloadType = Union[str, bytes, bytearray, int, float, None]
HTTPHeader = Dict[str, str]
WebSocketHeaders = Union[Callable[[HTTPHeader], HTTPHeader], HTTPHeader]
CleanStartOption = Union[bool, Literal[3]]
class ConnectFlags(NamedTuple):
    """Contains additional information passed to `on_connect` callback"""
    session_present: bool
    ...


class DisconnectFlags(NamedTuple):
    """Contains additional information passed to `on_disconnect` callback"""
    is_disconnect_packet_from_server: bool
    ...


CallbackOnConnect_v1_mqtt3 = Callable[["Client", Any, Dict[str, Any], MQTTErrorCode], None]
CallbackOnConnect_v1_mqtt5 = Callable[["Client", Any, Dict[str, Any], ReasonCode, Union[Properties, None]], None]
CallbackOnConnect_v1 = Union[CallbackOnConnect_v1_mqtt5, CallbackOnConnect_v1_mqtt3]
CallbackOnConnect_v2 = Callable[["Client", Any, ConnectFlags, ReasonCode, Union[Properties, None]], None]
CallbackOnConnect = Union[CallbackOnConnect_v1, CallbackOnConnect_v2]
CallbackOnConnectFail = Callable[["Client", Any], None]
CallbackOnDisconnect_v1_mqtt3 = Callable[["Client", Any, MQTTErrorCode], None]
CallbackOnDisconnect_v1_mqtt5 = Callable[["Client", Any, Union[ReasonCode, int, None], Union[Properties, None]], None]
CallbackOnDisconnect_v1 = Union[CallbackOnDisconnect_v1_mqtt3, CallbackOnDisconnect_v1_mqtt5]
CallbackOnDisconnect_v2 = Callable[["Client", Any, DisconnectFlags, ReasonCode, Union[Properties, None]], None]
CallbackOnDisconnect = Union[CallbackOnDisconnect_v1, CallbackOnDisconnect_v2]
CallbackOnLog = Callable[["Client", Any, int, str], None]
CallbackOnMessage = Callable[["Client", Any, "MQTTMessage"], None]
CallbackOnPreConnect = Callable[["Client", Any], None]
CallbackOnPublish_v1 = Callable[["Client", Any, int], None]
CallbackOnPublish_v2 = Callable[["Client", Any, int, ReasonCode, Properties], None]
CallbackOnPublish = Union[CallbackOnPublish_v1, CallbackOnPublish_v2]
CallbackOnSocket = Callable[["Client", Any, "SocketLike"], None]
CallbackOnSubscribe_v1_mqtt3 = Callable[["Client", Any, int, Tuple[int, ...]], None]
CallbackOnSubscribe_v1_mqtt5 = Callable[["Client", Any, int, List[ReasonCode], Properties], None]
CallbackOnSubscribe_v1 = Union[CallbackOnSubscribe_v1_mqtt3, CallbackOnSubscribe_v1_mqtt5]
CallbackOnSubscribe_v2 = Callable[["Client", Any, int, List[ReasonCode], Union[Properties, None]], None]
CallbackOnSubscribe = Union[CallbackOnSubscribe_v1, CallbackOnSubscribe_v2]
CallbackOnUnsubscribe_v1_mqtt3 = Callable[["Client", Any, int], None]
CallbackOnUnsubscribe_v1_mqtt5 = Callable[["Client", Any, int, Properties, Union[ReasonCode, List[ReasonCode]]], None]
CallbackOnUnsubscribe_v1 = Union[CallbackOnUnsubscribe_v1_mqtt3, CallbackOnUnsubscribe_v1_mqtt5]
CallbackOnUnsubscribe_v2 = Callable[["Client", Any, int, List[ReasonCode], Union[Properties, None]], None]
CallbackOnUnsubscribe = Union[CallbackOnUnsubscribe_v1, CallbackOnUnsubscribe_v2]
_socket = socket
class WebsocketConnectionError(ConnectionError):
    """ WebsocketConnectionError is a subclass of ConnectionError.

        It's raised when unable to perform the Websocket handshake.
    """
    ...


def error_string(mqtt_errno: MQTTErrorCode | int) -> str:
    """Return the error string associated with an mqtt error number."""
    ...

def connack_string(connack_code: int | ReasonCode) -> str:
    """Return the string associated with a CONNACK result or CONNACK reason code."""
    ...

def convert_connack_rc_to_reason_code(connack_code: ConnackCode) -> ReasonCode:
    """Convert a MQTTv3 / MQTTv3.1.1 connack result to `ReasonCode`.

    This is used in `on_connect` callback to have a consistent API.

    Be careful that the numeric value isn't the same, for example:

    >>> ConnackCode.CONNACK_REFUSED_SERVER_UNAVAILABLE == 3
    >>> convert_connack_rc_to_reason_code(ConnackCode.CONNACK_REFUSED_SERVER_UNAVAILABLE) == 136

    It's recommended to compare by names

    >>> code_to_test = ReasonCode(PacketTypes.CONNACK, "Server unavailable")
    >>> convert_connack_rc_to_reason_code(ConnackCode.CONNACK_REFUSED_SERVER_UNAVAILABLE) == code_to_test
    """
    ...

def convert_disconnect_error_code_to_reason_code(rc: MQTTErrorCode) -> ReasonCode:
    """Convert an MQTTErrorCode to Reason code.

    This is used in `on_disconnect` callback to have a consistent API.

    Be careful that the numeric value isn't the same, for example:

    >>> MQTTErrorCode.MQTT_ERR_PROTOCOL == 2
    >>> convert_disconnect_error_code_to_reason_code(MQTTErrorCode.MQTT_ERR_PROTOCOL) == 130

    It's recommended to compare by names

    >>> code_to_test = ReasonCode(PacketTypes.DISCONNECT, "Protocol error")
    >>> convert_disconnect_error_code_to_reason_code(MQTTErrorCode.MQTT_ERR_PROTOCOL) == code_to_test
    """
    ...

def topic_matches_sub(sub: str, topic: str) -> bool:
    """Check whether a topic matches a subscription.

    For example:

    * Topic "foo/bar" would match the subscription "foo/#" or "+/bar"
    * Topic "non/matching" would not match the subscription "non/+/+"
    """
    ...

class MQTTMessageInfo:
    """This is a class returned from `Client.publish()` and can be used to find
    out the mid of the message that was published, and to determine whether the
    message has been published, and/or wait until it is published.
    """
    __slots__ = ...
    def __init__(self, mid: int) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __iter__(self) -> Iterator[MQTTErrorCode | int]:
        ...
    
    def __next__(self) -> MQTTErrorCode | int:
        ...
    
    def next(self) -> MQTTErrorCode | int:
        ...
    
    def __getitem__(self, index: int) -> MQTTErrorCode | int:
        ...
    
    def wait_for_publish(self, timeout: float | None = ...) -> None:
        """Block until the message associated with this object is published, or
        until the timeout occurs. If timeout is None, this will never time out.
        Set timeout to a positive number of seconds, e.g. 1.2, to enable the
        timeout.

        :raises ValueError: if the message was not queued due to the outgoing
            queue being full.

        :raises RuntimeError: if the message was not published for another
            reason.
        """
        ...
    
    def is_published(self) -> bool:
        """Returns True if the message associated with this object has been
        published, else returns False.

        To wait for this to become true, look at `wait_for_publish`.
        """
        ...
    


class MQTTMessage:
    """ This is a class that describes an incoming message. It is
    passed to the `on_message` callback as the message parameter.
    """
    __slots__ = ...
    def __init__(self, mid: int = ..., topic: bytes = ...) -> None:
        ...
    
    def __eq__(self, other: object) -> bool:
        """Override the default Equals behavior"""
        ...
    
    def __ne__(self, other: object) -> bool:
        """Define a non-equality test"""
        ...
    
    @property
    def topic(self) -> str:
        """topic that the message was published on.

        This property is read-only.
        """
        ...
    
    @topic.setter
    def topic(self, value: bytes) -> None:
        ...
    


class Client:
    """MQTT version 3.1/3.1.1/5.0 client class.

    This is the main class for use communicating with an MQTT broker.

    General usage flow:

    * Use `connect()`, `connect_async()` or `connect_srv()` to connect to a broker
    * Use `loop_start()` to set a thread running to call `loop()` for you.
    * Or use `loop_forever()` to handle calling `loop()` for you in a blocking function.
    * Or call `loop()` frequently to maintain network traffic flow with the broker
    * Use `subscribe()` to subscribe to a topic and receive messages
    * Use `publish()` to send messages
    * Use `disconnect()` to disconnect from the broker

    Data returned from the broker is made available with the use of callback
    functions as described below.

    :param CallbackAPIVersion callback_api_version: define the API version for user-callback (on_connect, on_publish,...).
        This field is required and it's recommended to use the latest version (CallbackAPIVersion.API_VERSION2).
        See each callback for description of API for each version. The file docs/migrations.rst contains details on
        how to migrate between version.

    :param str client_id: the unique client id string used when connecting to the
        broker. If client_id is zero length or None, then the behaviour is
        defined by which protocol version is in use. If using MQTT v3.1.1, then
        a zero length client id will be sent to the broker and the broker will
        generate a random for the client. If using MQTT v3.1 then an id will be
        randomly generated. In both cases, clean_session must be True. If this
        is not the case a ValueError will be raised.

    :param bool clean_session: a boolean that determines the client type. If True,
        the broker will remove all information about this client when it
        disconnects. If False, the client is a persistent client and
        subscription information and queued messages will be retained when the
        client disconnects.
        Note that a client will never discard its own outgoing messages on
        disconnect. Calling connect() or reconnect() will cause the messages to
        be resent.  Use reinitialise() to reset a client to its original state.
        The clean_session argument only applies to MQTT versions v3.1.1 and v3.1.
        It is not accepted if the MQTT version is v5.0 - use the clean_start
        argument on connect() instead.

    :param userdata: user defined data of any type that is passed as the "userdata"
        parameter to callbacks. It may be updated at a later point with the
        user_data_set() function.

    :param int protocol: allows explicit setting of the MQTT version to
        use for this client. Can be paho.mqtt.client.MQTTv311 (v3.1.1),
        paho.mqtt.client.MQTTv31 (v3.1) or paho.mqtt.client.MQTTv5 (v5.0),
        with the default being v3.1.1.

    :param transport: use "websockets" to use WebSockets as the transport
        mechanism. Set to "tcp" to use raw TCP, which is the default.
        Use "unix" to use Unix sockets as the transport mechanism; note that
        this option is only available on platforms that support Unix sockets,
        and the "host" argument is interpreted as the path to the Unix socket
        file in this case.

    :param bool manual_ack: normally, when a message is received, the library automatically
        acknowledges after on_message callback returns.  manual_ack=True allows the application to
        acknowledge receipt after it has completed processing of a message
        using a the ack() method. This addresses vulnerability to message loss
        if applications fails while processing a message, or while it pending
        locally.

    Callbacks
    =========

    A number of callback functions are available to receive data back from the
    broker. To use a callback, define a function and then assign it to the
    client::

        def on_connect(client, userdata, flags, reason_code, properties):
            print(f"Connected with result code {reason_code}")

        client.on_connect = on_connect

    Callbacks can also be attached using decorators::

        mqttc = paho.mqtt.Client()

        @mqttc.connect_callback()
        def on_connect(client, userdata, flags, reason_code, properties):
            print(f"Connected with result code {reason_code}")

    All of the callbacks as described below have a "client" and an "userdata"
    argument. "client" is the `Client` instance that is calling the callback.
    userdata" is user data of any type and can be set when creating a new client
    instance or with `user_data_set()`.

    If you wish to suppress exceptions within a callback, you should set
    ``mqttc.suppress_exceptions = True``

    The callbacks are listed below, documentation for each of them can be found
    at the same function name:

    `on_connect`, `on_connect_fail`, `on_disconnect`, `on_message`, `on_publish`,
    `on_subscribe`, `on_unsubscribe`, `on_log`, `on_socket_open`, `on_socket_close`,
    `on_socket_register_write`, `on_socket_unregister_write`
    """
    def __init__(self, callback_api_version: CallbackAPIVersion = ..., client_id: str | None = ..., clean_session: bool | None = ..., userdata: Any = ..., protocol: MQTTProtocolVersion = ..., transport: Literal["tcp", "websockets", "unix"] = ..., reconnect_on_failure: bool = ..., manual_ack: bool = ...) -> None:
        ...
    
    def __del__(self) -> None:
        ...
    
    @property
    def host(self) -> str:
        """
        Host to connect to. If `connect()` hasn't been called yet, returns an empty string.

        This property may not be changed if the connection is already open.
        """
        ...
    
    @host.setter
    def host(self, value: str) -> None:
        ...
    
    @property
    def port(self) -> int:
        """
        Broker TCP port to connect to.

        This property may not be changed if the connection is already open.
        """
        ...
    
    @port.setter
    def port(self, value: int) -> None:
        ...
    
    @property
    def keepalive(self) -> int:
        """
        Client keepalive interval (in seconds).

        This property may not be changed if the connection is already open.
        """
        ...
    
    @keepalive.setter
    def keepalive(self, value: int) -> None:
        ...
    
    @property
    def transport(self) -> Literal["tcp", "websockets", "unix"]:
        """
        Transport method used for the connection ("tcp" or "websockets").

        This property may not be changed if the connection is already open.
        """
        ...
    
    @transport.setter
    def transport(self, value: Literal["tcp", "websockets"]) -> None:
        ...
    
    @property
    def protocol(self) -> MQTTProtocolVersion:
        """
        Protocol version used (MQTT v3, MQTT v3.11, MQTTv5)

        This property is read-only.
        """
        ...
    
    @property
    def connect_timeout(self) -> float:
        """
        Connection establishment timeout in seconds.

        This property may not be changed if the connection is already open.
        """
        ...
    
    @connect_timeout.setter
    def connect_timeout(self, value: float) -> None:
        ...
    
    @property
    def username(self) -> str | None:
        """The username used to connect to the MQTT broker, or None if no username is used.

        This property may not be changed if the connection is already open.
        """
        ...
    
    @username.setter
    def username(self, value: str | None) -> None:
        ...
    
    @property
    def password(self) -> str | None:
        """The password used to connect to the MQTT broker, or None if no password is used.

        This property may not be changed if the connection is already open.
        """
        ...
    
    @password.setter
    def password(self, value: str | None) -> None:
        ...
    
    @property
    def max_inflight_messages(self) -> int:
        """
        Maximum number of messages with QoS > 0 that can be partway through the network flow at once

        This property may not be changed if the connection is already open.
        """
        ...
    
    @max_inflight_messages.setter
    def max_inflight_messages(self, value: int) -> None:
        ...
    
    @property
    def max_queued_messages(self) -> int:
        """
        Maximum number of message in the outgoing message queue, 0 means unlimited

        This property may not be changed if the connection is already open.
        """
        ...
    
    @max_queued_messages.setter
    def max_queued_messages(self, value: int) -> None:
        ...
    
    @property
    def will_topic(self) -> str | None:
        """
        The topic name a will message is sent to when disconnecting unexpectedly. None if a will shall not be sent.

        This property is read-only. Use `will_set()` to change its value.
        """
        ...
    
    @property
    def will_payload(self) -> bytes | None:
        """
        The payload for the will message that is sent when disconnecting unexpectedly. None if a will shall not be sent.

        This property is read-only. Use `will_set()` to change its value.
        """
        ...
    
    @property
    def logger(self) -> logging.Logger | None:
        ...
    
    @logger.setter
    def logger(self, value: logging.Logger | None) -> None:
        ...
    
    def reinitialise(self, client_id: str = ..., clean_session: bool = ..., userdata: Any = ...) -> None:
        ...
    
    def ws_set_options(self, path: str = ..., headers: WebSocketHeaders | None = ...) -> None:
        """ Set the path and headers for a websocket connection

        :param str path: a string starting with / which should be the endpoint of the
            mqtt connection on the remote server

        :param headers:  can be either a dict or a callable object. If it is a dict then
            the extra items in the dict are added to the websocket headers. If it is
            a callable, then the default websocket headers are passed into this
            function and the result is used as the new headers.
        """
        ...
    
    def tls_set_context(self, context: ssl.SSLContext | None = ...) -> None:
        """Configure network encryption and authentication context. Enables SSL/TLS support.

        :param context: an ssl.SSLContext object. By default this is given by
            ``ssl.create_default_context()``, if available.

        Must be called before `connect()`, `connect_async()` or `connect_srv()`."""
        ...
    
    def tls_set(self, ca_certs: str | None = ..., certfile: str | None = ..., keyfile: str | None = ..., cert_reqs: ssl.VerifyMode | None = ..., tls_version: int | None = ..., ciphers: str | None = ..., keyfile_password: str | None = ..., alpn_protocols: list[str] | None = ...) -> None:
        """Configure network encryption and authentication options. Enables SSL/TLS support.

        :param str ca_certs: a string path to the Certificate Authority certificate files
            that are to be treated as trusted by this client. If this is the only
            option given then the client will operate in a similar manner to a web
            browser. That is to say it will require the broker to have a
            certificate signed by the Certificate Authorities in ca_certs and will
            communicate using TLS v1,2, but will not attempt any form of
            authentication. This provides basic network encryption but may not be
            sufficient depending on how the broker is configured.

            By default, on Python 2.7.9+ or 3.4+, the default certification
            authority of the system is used. On older Python version this parameter
            is mandatory.
        :param str certfile: PEM encoded client certificate filename. Used with
            keyfile for client TLS based authentication. Support for this feature is
            broker dependent. Note that if the files in encrypted and needs a password to
            decrypt it, then this can be passed using the keyfile_password argument - you
            should take precautions to ensure that your password is
            not hard coded into your program by loading the password from a file
            for example. If you do not provide keyfile_password, the password will
            be requested to be typed in at a terminal window.
        :param str keyfile: PEM encoded client private keys filename. Used with
            certfile for client TLS based authentication. Support for this feature is
            broker dependent. Note that if the files in encrypted and needs a password to
            decrypt it, then this can be passed using the keyfile_password argument - you
            should take precautions to ensure that your password is
            not hard coded into your program by loading the password from a file
            for example. If you do not provide keyfile_password, the password will
            be requested to be typed in at a terminal window.
        :param cert_reqs: the certificate requirements that the client imposes
            on the broker to be changed. By default this is ssl.CERT_REQUIRED,
            which means that the broker must provide a certificate. See the ssl
            pydoc for more information on this parameter.
        :param tls_version: the version of the SSL/TLS protocol used to be
            specified. By default TLS v1.2 is used. Previous versions are allowed
            but not recommended due to possible security problems.
        :param str ciphers: encryption ciphers that are allowed
            for this connection, or None to use the defaults. See the ssl pydoc for
            more information.

        Must be called before `connect()`, `connect_async()` or `connect_srv()`."""
        ...
    
    def tls_insecure_set(self, value: bool) -> None:
        """Configure verification of the server hostname in the server certificate.

        If value is set to true, it is impossible to guarantee that the host
        you are connecting to is not impersonating your server. This can be
        useful in initial server testing, but makes it possible for a malicious
        third party to impersonate your server through DNS spoofing, for
        example.

        Do not use this function in a real system. Setting value to true means
        there is no point using encryption.

        Must be called before `connect()` and after either `tls_set()` or
        `tls_set_context()`."""
        ...
    
    def proxy_set(self, **proxy_args: Any) -> None:
        """Configure proxying of MQTT connection. Enables support for SOCKS or
        HTTP proxies.

        Proxying is done through the PySocks library. Brief descriptions of the
        proxy_args parameters are below; see the PySocks docs for more info.

        (Required)

        :param proxy_type: One of {socks.HTTP, socks.SOCKS4, or socks.SOCKS5}
        :param proxy_addr: IP address or DNS name of proxy server

        (Optional)

        :param proxy_port: (int) port number of the proxy server. If not provided,
            the PySocks package default value will be utilized, which differs by proxy_type.
        :param proxy_rdns: boolean indicating whether proxy lookup should be performed
            remotely (True, default) or locally (False)
        :param proxy_username: username for SOCKS5 proxy, or userid for SOCKS4 proxy
        :param proxy_password: password for SOCKS5 proxy

        Example::

            mqttc.proxy_set(proxy_type=socks.HTTP, proxy_addr='1.2.3.4', proxy_port=4231)
        """
        ...
    
    def enable_logger(self, logger: logging.Logger | None = ...) -> None:
        """
        Enables a logger to send log messages to

        :param logging.Logger logger: if specified, that ``logging.Logger`` object will be used, otherwise
            one will be created automatically.

        See `disable_logger` to undo this action.
        """
        ...
    
    def disable_logger(self) -> None:
        """
        Disable logging using standard python logging package. This has no effect on the `on_log` callback.
        """
        ...
    
    def connect(self, host: str, port: int = ..., keepalive: int = ..., bind_address: str = ..., bind_port: int = ..., clean_start: CleanStartOption = ..., properties: Properties | None = ...) -> MQTTErrorCode:
        """Connect to a remote broker. This is a blocking call that establishes
        the underlying connection and transmits a CONNECT packet.
        Note that the connection status will not be updated until a CONNACK is received and
        processed (this requires a running network loop, see `loop_start`, `loop_forever`, `loop`...).

        :param str host: the hostname or IP address of the remote broker.
        :param int port: the network port of the server host to connect to. Defaults to
            1883. Note that the default port for MQTT over SSL/TLS is 8883 so if you
            are using `tls_set()` the port may need providing.
        :param int keepalive: Maximum period in seconds between communications with the
            broker. If no other messages are being exchanged, this controls the
            rate at which the client will send ping messages to the broker.
        :param bool clean_start: (MQTT v5.0 only) True, False or MQTT_CLEAN_START_FIRST_ONLY.
            Sets the MQTT v5.0 clean_start flag always, never or on the first successful connect only,
            respectively.  MQTT session data (such as outstanding messages and subscriptions)
            is cleared on successful connect when the clean_start flag is set.
            For MQTT v3.1.1, the ``clean_session`` argument of `Client` should be used for similar
            result.
        :param Properties properties: (MQTT v5.0 only) the MQTT v5.0 properties to be sent in the
            MQTT connect packet.
        """
        ...
    
    def connect_srv(self, domain: str | None = ..., keepalive: int = ..., bind_address: str = ..., bind_port: int = ..., clean_start: CleanStartOption = ..., properties: Properties | None = ...) -> MQTTErrorCode:
        """Connect to a remote broker.

        :param str domain: the DNS domain to search for SRV records; if None,
            try to determine local domain name.
        :param keepalive, bind_address, clean_start and properties: see `connect()`
        """
        ...
    
    def connect_async(self, host: str, port: int = ..., keepalive: int = ..., bind_address: str = ..., bind_port: int = ..., clean_start: CleanStartOption = ..., properties: Properties | None = ...) -> None:
        """Connect to a remote broker asynchronously. This is a non-blocking
        connect call that can be used with `loop_start()` to provide very quick
        start.

        Any already established connection will be terminated immediately.

        :param str host: the hostname or IP address of the remote broker.
        :param int port: the network port of the server host to connect to. Defaults to
            1883. Note that the default port for MQTT over SSL/TLS is 8883 so if you
            are using `tls_set()` the port may need providing.
        :param int keepalive: Maximum period in seconds between communications with the
            broker. If no other messages are being exchanged, this controls the
            rate at which the client will send ping messages to the broker.
        :param bool clean_start: (MQTT v5.0 only) True, False or MQTT_CLEAN_START_FIRST_ONLY.
            Sets the MQTT v5.0 clean_start flag always, never or on the first successful connect only,
            respectively.  MQTT session data (such as outstanding messages and subscriptions)
            is cleared on successful connect when the clean_start flag is set.
            For MQTT v3.1.1, the ``clean_session`` argument of `Client` should be used for similar
            result.
        :param Properties properties: (MQTT v5.0 only) the MQTT v5.0 properties to be sent in the
            MQTT connect packet.
        """
        ...
    
    def reconnect_delay_set(self, min_delay: int = ..., max_delay: int = ...) -> None:
        """ Configure the exponential reconnect delay

            When connection is lost, wait initially min_delay seconds and
            double this time every attempt. The wait is capped at max_delay.
            Once the client is fully connected (e.g. not only TCP socket, but
            received a success CONNACK), the wait timer is reset to min_delay.
        """
        ...
    
    def reconnect(self) -> MQTTErrorCode:
        """Reconnect the client after a disconnect. Can only be called after
        connect()/connect_async()."""
        ...
    
    def loop(self, timeout: float = ...) -> MQTTErrorCode:
        """Process network events.

        It is strongly recommended that you use `loop_start()`, or
        `loop_forever()`, or if you are using an external event loop using
        `loop_read()`, `loop_write()`, and `loop_misc()`. Using loop() on it's own is
        no longer recommended.

        This function must be called regularly to ensure communication with the
        broker is carried out. It calls select() on the network socket to wait
        for network events. If incoming data is present it will then be
        processed. Outgoing commands, from e.g. `publish()`, are normally sent
        immediately that their function is called, but this is not always
        possible. loop() will also attempt to send any remaining outgoing
        messages, which also includes commands that are part of the flow for
        messages with QoS>0.

        :param int timeout: The time in seconds to wait for incoming/outgoing network
            traffic before timing out and returning.

        Returns MQTT_ERR_SUCCESS on success.
        Returns >0 on error.

        A ValueError will be raised if timeout < 0"""
        ...
    
    def publish(self, topic: str, payload: PayloadType = ..., qos: int = ..., retain: bool = ..., properties: Properties | None = ...) -> MQTTMessageInfo:
        """Publish a message on a topic.

        This causes a message to be sent to the broker and subsequently from
        the broker to any clients subscribing to matching topics.

        :param str topic: The topic that the message should be published on.
        :param payload: The actual message to send. If not given, or set to None a
            zero length message will be used. Passing an int or float will result
            in the payload being converted to a string representing that number. If
            you wish to send a true int/float, use struct.pack() to create the
            payload you require.
        :param int qos: The quality of service level to use.
        :param bool retain: If set to true, the message will be set as the "last known
            good"/retained message for the topic.
        :param Properties properties: (MQTT v5.0 only) the MQTT v5.0 properties to be included.

        Returns a `MQTTMessageInfo` class, which can be used to determine whether
        the message has been delivered (using `is_published()`) or to block
        waiting for the message to be delivered (`wait_for_publish()`). The
        message ID and return code of the publish() call can be found at
        :py:attr:`info.mid <MQTTMessage.mid>` and :py:attr:`info.rc <MQTTMessage.rc>`.

        For backwards compatibility, the `MQTTMessageInfo` class is iterable so
        the old construct of ``(rc, mid) = client.publish(...)`` is still valid.

        rc is MQTT_ERR_SUCCESS to indicate success or MQTT_ERR_NO_CONN if the
        client is not currently connected.  mid is the message ID for the
        publish request. The mid value can be used to track the publish request
        by checking against the mid argument in the on_publish() callback if it
        is defined.

        :raises ValueError: if topic is None, has zero length or is
            invalid (contains a wildcard), except if the MQTT version used is v5.0.
            For v5.0, a zero length topic can be used when a Topic Alias has been set.
        :raises ValueError: if qos is not one of 0, 1 or 2
        :raises ValueError: if the length of the payload is greater than 268435455 bytes.
        """
        ...
    
    def username_pw_set(self, username: str | None, password: str | None = ...) -> None:
        """Set a username and optionally a password for broker authentication.

        Must be called before connect() to have any effect.
        Requires a broker that supports MQTT v3.1 or more.

        :param str username: The username to authenticate with. Need have no relationship to the client id. Must be str
            [MQTT-3.1.3-11].
            Set to None to reset client back to not using username/password for broker authentication.
        :param str password: The password to authenticate with. Optional, set to None if not required. If it is str, then it
            will be encoded as UTF-8.
        """
        ...
    
    def enable_bridge_mode(self) -> None:
        """Sets the client in a bridge mode instead of client mode.

        Must be called before `connect()` to have any effect.
        Requires brokers that support bridge mode.

        Under bridge mode, the broker will identify the client as a bridge and
        not send it's own messages back to it. Hence a subsciption of # is
        possible without message loops. This feature also correctly propagates
        the retain flag on the messages.

        Currently Mosquitto and RSMB support this feature. This feature can
        be used to create a bridge between multiple broker.
        """
        ...
    
    def is_connected(self) -> bool:
        """Returns the current status of the connection

        True if connection exists
        False if connection is closed
        """
        ...
    
    def disconnect(self, reasoncode: ReasonCode | None = ..., properties: Properties | None = ...) -> MQTTErrorCode:
        """Disconnect a connected client from the broker.

        :param ReasonCode reasoncode: (MQTT v5.0 only) a ReasonCode instance setting the MQTT v5.0
            reasoncode to be sent with the disconnect packet. It is optional, the receiver
            then assuming that 0 (success) is the value.
        :param Properties properties: (MQTT v5.0 only) a Properties instance setting the MQTT v5.0 properties
            to be included. Optional - if not set, no properties are sent.
        """
        ...
    
    def subscribe(self, topic: str | tuple[str, int] | tuple[str, SubscribeOptions] | list[tuple[str, int]] | list[tuple[str, SubscribeOptions]], qos: int = ..., options: SubscribeOptions | None = ..., properties: Properties | None = ...) -> tuple[MQTTErrorCode, int | None]:
        """Subscribe the client to one or more topics.

        This function may be called in three different ways (and a further three for MQTT v5.0):

        Simple string and integer
        -------------------------
        e.g. subscribe("my/topic", 2)

        :topic: A string specifying the subscription topic to subscribe to.
        :qos: The desired quality of service level for the subscription.
            Defaults to 0.
        :options and properties: Not used.

        Simple string and subscribe options (MQTT v5.0 only)
        ----------------------------------------------------
        e.g. subscribe("my/topic", options=SubscribeOptions(qos=2))

        :topic: A string specifying the subscription topic to subscribe to.
        :qos: Not used.
        :options: The MQTT v5.0 subscribe options.
        :properties: a Properties instance setting the MQTT v5.0 properties
            to be included. Optional - if not set, no properties are sent.

        String and integer tuple
        ------------------------
        e.g. subscribe(("my/topic", 1))

        :topic: A tuple of (topic, qos). Both topic and qos must be present in
               the tuple.
        :qos and options: Not used.
        :properties: Only used for MQTT v5.0.  A Properties instance setting the
            MQTT v5.0 properties. Optional - if not set, no properties are sent.

        String and subscribe options tuple (MQTT v5.0 only)
        ---------------------------------------------------
        e.g. subscribe(("my/topic", SubscribeOptions(qos=1)))

        :topic: A tuple of (topic, SubscribeOptions). Both topic and subscribe
                options must be present in the tuple.
        :qos and options: Not used.
        :properties: a Properties instance setting the MQTT v5.0 properties
            to be included. Optional - if not set, no properties are sent.

        List of string and integer tuples
        ---------------------------------
        e.g. subscribe([("my/topic", 0), ("another/topic", 2)])

        This allows multiple topic subscriptions in a single SUBSCRIPTION
        command, which is more efficient than using multiple calls to
        subscribe().

        :topic: A list of tuple of format (topic, qos). Both topic and qos must
               be present in all of the tuples.
        :qos, options and properties: Not used.

        List of string and subscribe option tuples (MQTT v5.0 only)
        -----------------------------------------------------------
        e.g. subscribe([("my/topic", SubscribeOptions(qos=0), ("another/topic", SubscribeOptions(qos=2)])

        This allows multiple topic subscriptions in a single SUBSCRIPTION
        command, which is more efficient than using multiple calls to
        subscribe().

        :topic: A list of tuple of format (topic, SubscribeOptions). Both topic and subscribe
                options must be present in all of the tuples.
        :qos and options: Not used.
        :properties: a Properties instance setting the MQTT v5.0 properties
            to be included. Optional - if not set, no properties are sent.

        The function returns a tuple (result, mid), where result is
        MQTT_ERR_SUCCESS to indicate success or (MQTT_ERR_NO_CONN, None) if the
        client is not currently connected.  mid is the message ID for the
        subscribe request. The mid value can be used to track the subscribe
        request by checking against the mid argument in the on_subscribe()
        callback if it is defined.

        Raises a ValueError if qos is not 0, 1 or 2, or if topic is None or has
        zero string length, or if topic is not a string, tuple or list.
        """
        ...
    
    def unsubscribe(self, topic: str | list[str], properties: Properties | None = ...) -> tuple[MQTTErrorCode, int | None]:
        """Unsubscribe the client from one or more topics.

        :param topic: A single string, or list of strings that are the subscription
            topics to unsubscribe from.
        :param properties: (MQTT v5.0 only) a Properties instance setting the MQTT v5.0 properties
            to be included. Optional - if not set, no properties are sent.

        Returns a tuple (result, mid), where result is MQTT_ERR_SUCCESS
        to indicate success or (MQTT_ERR_NO_CONN, None) if the client is not
        currently connected.
        mid is the message ID for the unsubscribe request. The mid value can be
        used to track the unsubscribe request by checking against the mid
        argument in the on_unsubscribe() callback if it is defined.

        :raises ValueError: if topic is None or has zero string length, or is
            not a string or list.
        """
        ...
    
    def loop_read(self, max_packets: int = ...) -> MQTTErrorCode:
        """Process read network events. Use in place of calling `loop()` if you
        wish to handle your client reads as part of your own application.

        Use `socket()` to obtain the client socket to call select() or equivalent
        on.

        Do not use if you are using `loop_start()` or `loop_forever()`."""
        ...
    
    def loop_write(self) -> MQTTErrorCode:
        """Process write network events. Use in place of calling `loop()` if you
        wish to handle your client writes as part of your own application.

        Use `socket()` to obtain the client socket to call select() or equivalent
        on.

        Use `want_write()` to determine if there is data waiting to be written.

        Do not use if you are using `loop_start()` or `loop_forever()`."""
        ...
    
    def want_write(self) -> bool:
        """Call to determine if there is network data waiting to be written.
        Useful if you are calling select() yourself rather than using `loop()`, `loop_start()` or `loop_forever()`.
        """
        ...
    
    def loop_misc(self) -> MQTTErrorCode:
        """Process miscellaneous network events. Use in place of calling `loop()` if you
        wish to call select() or equivalent on.

        Do not use if you are using `loop_start()` or `loop_forever()`."""
        ...
    
    def max_inflight_messages_set(self, inflight: int) -> None:
        """Set the maximum number of messages with QoS>0 that can be part way
        through their network flow at once. Defaults to 20."""
        ...
    
    def max_queued_messages_set(self, queue_size: int) -> Client:
        """Set the maximum number of messages in the outgoing message queue.
        0 means unlimited."""
        ...
    
    def user_data_set(self, userdata: Any) -> None:
        """Set the user data variable passed to callbacks. May be any data type."""
        ...
    
    def user_data_get(self) -> Any:
        """Get the user data variable passed to callbacks. May be any data type."""
        ...
    
    def will_set(self, topic: str, payload: PayloadType = ..., qos: int = ..., retain: bool = ..., properties: Properties | None = ...) -> None:
        """Set a Will to be sent by the broker in case the client disconnects unexpectedly.

        This must be called before connect() to have any effect.

        :param str topic: The topic that the will message should be published on.
        :param payload: The message to send as a will. If not given, or set to None a
            zero length message will be used as the will. Passing an int or float
            will result in the payload being converted to a string representing
            that number. If you wish to send a true int/float, use struct.pack() to
            create the payload you require.
        :param int qos: The quality of service level to use for the will.
        :param bool retain: If set to true, the will message will be set as the "last known
            good"/retained message for the topic.
        :param Properties properties: (MQTT v5.0 only) the MQTT v5.0 properties
            to be included with the will message. Optional - if not set, no properties are sent.

        :raises ValueError: if qos is not 0, 1 or 2, or if topic is None or has
            zero string length.

        See `will_clear` to clear will. Note that will are NOT send if the client disconnect cleanly
        for example by calling `disconnect()`.
        """
        ...
    
    def will_clear(self) -> None:
        """ Removes a will that was previously configured with `will_set()`.

        Must be called before connect() to have any effect."""
        ...
    
    def socket(self) -> SocketLike | None:
        """Return the socket or ssl object for this client."""
        ...
    
    def loop_forever(self, timeout: float = ..., retry_first_connection: bool = ...) -> MQTTErrorCode:
        """This function calls the network loop functions for you in an
        infinite blocking loop. It is useful for the case where you only want
        to run the MQTT client loop in your program.

        loop_forever() will handle reconnecting for you if reconnect_on_failure is
        true (this is the default behavior). If you call `disconnect()` in a callback
        it will return.

        :param int timeout: The time in seconds to wait for incoming/outgoing network
          traffic before timing out and returning.
        :param bool retry_first_connection: Should the first connection attempt be retried on failure.
          This is independent of the reconnect_on_failure setting.

        :raises OSError: if the first connection fail unless retry_first_connection=True
        """
        ...
    
    def loop_start(self) -> MQTTErrorCode:
        """This is part of the threaded client interface. Call this once to
        start a new thread to process network traffic. This provides an
        alternative to repeatedly calling `loop()` yourself.

        Under the hood, this will call `loop_forever` in a thread, which means that
        the thread will terminate if you call `disconnect()`
        """
        ...
    
    def loop_stop(self) -> MQTTErrorCode:
        """This is part of the threaded client interface. Call this once to
        stop the network thread previously created with `loop_start()`. This call
        will block until the network thread finishes.

        This don't guarantee that publish packet are sent, use `wait_for_publish` or
        `on_publish` to ensure `publish` are sent.
        """
        ...
    
    @property
    def callback_api_version(self) -> CallbackAPIVersion:
        """
        Return the callback API version used for user-callback. See docstring for
        each user-callback (`on_connect`, `on_publish`, ...) for details.

        This property is read-only.
        """
        ...
    
    @property
    def on_log(self) -> CallbackOnLog | None:
        """The callback called when the client has log information.
        Defined to allow debugging.

        Expected signature is::

            log_callback(client, userdata, level, buf)

        :param Client client: the client instance for this callback
        :param userdata: the private user data as set in Client() or user_data_set()
        :param int level: gives the severity of the message and will be one of
                    MQTT_LOG_INFO, MQTT_LOG_NOTICE, MQTT_LOG_WARNING,
                    MQTT_LOG_ERR, and MQTT_LOG_DEBUG.
        :param str buf: the message itself

        Decorator: @client.log_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_log.setter
    def on_log(self, func: CallbackOnLog | None) -> None:
        ...
    
    def log_callback(self) -> Callable[[CallbackOnLog], CallbackOnLog]:
        ...
    
    @property
    def on_pre_connect(self) -> CallbackOnPreConnect | None:
        """The callback called immediately prior to the connection is made
        request.

        Expected signature (for all callback API version)::

            connect_callback(client, userdata)

        :parama Client client: the client instance for this callback
        :parama userdata: the private user data as set in Client() or user_data_set()

        Decorator: @client.pre_connect_callback() (``client`` is the name of the
            instance which this callback is being attached to)

        """
        ...
    
    @on_pre_connect.setter
    def on_pre_connect(self, func: CallbackOnPreConnect | None) -> None:
        ...
    
    def pre_connect_callback(self) -> Callable[[CallbackOnPreConnect], CallbackOnPreConnect]:
        ...
    
    @property
    def on_connect(self) -> CallbackOnConnect | None:
        """The callback called when the broker reponds to our connection request.

        Expected signature for callback API version 2::

            connect_callback(client, userdata, connect_flags, reason_code, properties)

        Expected signature for callback API version 1 change with MQTT protocol version:
            * For MQTT v3.1 and v3.1.1 it's::

                connect_callback(client, userdata, flags, rc)

            * For MQTT v5.0 it's::

                connect_callback(client, userdata, flags, reason_code, properties)


        :param Client client: the client instance for this callback
        :param userdata: the private user data as set in Client() or user_data_set()
        :param ConnectFlags connect_flags: the flags for this connection
        :param ReasonCode reason_code: the connection reason code received from the broken.
                       In MQTT v5.0 it's the reason code defined by the standard.
                       In MQTT v3, we convert return code to a reason code, see
                       `convert_connack_rc_to_reason_code()`.
                       `ReasonCode` may be compared to integer.
        :param Properties properties: the MQTT v5.0 properties received from the broker.
                       For MQTT v3.1 and v3.1.1 properties is not provided and an empty Properties
                       object is always used.
        :param dict flags: response flags sent by the broker
        :param int rc: the connection result, should have a value of `ConnackCode`

        flags is a dict that contains response flags from the broker:
            flags['session present'] - this flag is useful for clients that are
                using clean session set to 0 only. If a client with clean
                session=0, that reconnects to a broker that it has previously
                connected to, this flag indicates whether the broker still has the
                session information for the client. If 1, the session still exists.

        The value of rc indicates success or not:
            - 0: Connection successful
            - 1: Connection refused - incorrect protocol version
            - 2: Connection refused - invalid client identifier
            - 3: Connection refused - server unavailable
            - 4: Connection refused - bad username or password
            - 5: Connection refused - not authorised
            - 6-255: Currently unused.

        Decorator: @client.connect_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_connect.setter
    def on_connect(self, func: CallbackOnConnect | None) -> None:
        ...
    
    def connect_callback(self) -> Callable[[CallbackOnConnect], CallbackOnConnect]:
        ...
    
    @property
    def on_connect_fail(self) -> CallbackOnConnectFail | None:
        """The callback called when the client failed to connect
        to the broker.

        Expected signature is (for all callback_api_version)::

            connect_fail_callback(client, userdata)

        :param Client client: the client instance for this callback
        :parama userdata: the private user data as set in Client() or user_data_set()

        Decorator: @client.connect_fail_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_connect_fail.setter
    def on_connect_fail(self, func: CallbackOnConnectFail | None) -> None:
        ...
    
    def connect_fail_callback(self) -> Callable[[CallbackOnConnectFail], CallbackOnConnectFail]:
        ...
    
    @property
    def on_subscribe(self) -> CallbackOnSubscribe | None:
        """The callback called when the broker responds to a subscribe
        request.

        Expected signature for callback API version 2::

            subscribe_callback(client, userdata, mid, reason_code_list, properties)

        Expected signature for callback API version 1 change with MQTT protocol version:
            * For MQTT v3.1 and v3.1.1 it's::

                subscribe_callback(client, userdata, mid, granted_qos)

            * For MQTT v5.0 it's::

                subscribe_callback(client, userdata, mid, reason_code_list, properties)

        :param Client client: the client instance for this callback
        :param userdata: the private user data as set in Client() or user_data_set()
        :param int mid: matches the mid variable returned from the corresponding
                          subscribe() call.
        :param list[ReasonCode] reason_code_list: reason codes received from the broker for each subscription.
                          In MQTT v5.0 it's the reason code defined by the standard.
                          In MQTT v3, we convert granted QoS to a reason code.
                          It's a list of ReasonCode instances.
        :param Properties properties: the MQTT v5.0 properties received from the broker.
                          For MQTT v3.1 and v3.1.1 properties is not provided and an empty Properties
                          object is always used.
        :param list[int] granted_qos: list of integers that give the QoS level the broker has
                          granted for each of the different subscription requests.

        Decorator: @client.subscribe_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_subscribe.setter
    def on_subscribe(self, func: CallbackOnSubscribe | None) -> None:
        ...
    
    def subscribe_callback(self) -> Callable[[CallbackOnSubscribe], CallbackOnSubscribe]:
        ...
    
    @property
    def on_message(self) -> CallbackOnMessage | None:
        """The callback called when a message has been received on a topic
        that the client subscribes to.

        This callback will be called for every message received unless a
        `message_callback_add()` matched the message.

        Expected signature is (for all callback API version):
            message_callback(client, userdata, message)

        :param Client client: the client instance for this callback
        :param userdata: the private user data as set in Client() or user_data_set()
        :param MQTTMessage message: the received message.
                    This is a class with members topic, payload, qos, retain.

        Decorator: @client.message_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_message.setter
    def on_message(self, func: CallbackOnMessage | None) -> None:
        ...
    
    def message_callback(self) -> Callable[[CallbackOnMessage], CallbackOnMessage]:
        ...
    
    @property
    def on_publish(self) -> CallbackOnPublish | None:
        """The callback called when a message that was to be sent using the
        `publish()` call has completed transmission to the broker.

        For messages with QoS levels 1 and 2, this means that the appropriate
        handshakes have completed. For QoS 0, this simply means that the message
        has left the client.
        This callback is important because even if the `publish()` call returns
        success, it does not always mean that the message has been sent.

        See also `wait_for_publish` which could be simpler to use.

        Expected signature for callback API version 2::

            publish_callback(client, userdata, mid, reason_code, properties)

        Expected signature for callback API version 1::

            publish_callback(client, userdata, mid)

        :param Client client: the client instance for this callback
        :param userdata: the private user data as set in Client() or user_data_set()
        :param int mid: matches the mid variable returned from the corresponding
                     `publish()` call, to allow outgoing messages to be tracked.
        :param ReasonCode reason_code: the connection reason code received from the broken.
                     In MQTT v5.0 it's the reason code defined by the standard.
                     In MQTT v3 it's always the reason code Success
        :parama Properties properties: the MQTT v5.0 properties received from the broker.
                     For MQTT v3.1 and v3.1.1 properties is not provided and an empty Properties
                     object is always used.

        Note: for QoS = 0, the reason_code and the properties don't really exist, it's the client
        library that generate them. It's always an empty properties and a success reason code.
        Because the (MQTTv5) standard don't have reason code for PUBLISH packet, the library create them
        at PUBACK packet, as if the message was sent with QoS = 1.

        Decorator: @client.publish_callback() (``client`` is the name of the
            instance which this callback is being attached to)

        """
        ...
    
    @on_publish.setter
    def on_publish(self, func: CallbackOnPublish | None) -> None:
        ...
    
    def publish_callback(self) -> Callable[[CallbackOnPublish], CallbackOnPublish]:
        ...
    
    @property
    def on_unsubscribe(self) -> CallbackOnUnsubscribe | None:
        """The callback called when the broker responds to an unsubscribe
        request.

        Expected signature for callback API version 2::

            unsubscribe_callback(client, userdata, mid, reason_code_list, properties)

        Expected signature for callback API version 1 change with MQTT protocol version:
            * For MQTT v3.1 and v3.1.1 it's::

                unsubscribe_callback(client, userdata, mid)

            * For MQTT v5.0 it's::

                unsubscribe_callback(client, userdata, mid, properties, v1_reason_codes)

        :param Client client: the client instance for this callback
        :param userdata: the private user data as set in Client() or user_data_set()
        :param mid: matches the mid variable returned from the corresponding
                          unsubscribe() call.
        :param list[ReasonCode] reason_code_list: reason codes received from the broker for each unsubscription.
                          In MQTT v5.0 it's the reason code defined by the standard.
                          In MQTT v3, there is not equivalent from broken and empty list
                          is always used.
        :param Properties properties: the MQTT v5.0 properties received from the broker.
                          For MQTT v3.1 and v3.1.1 properties is not provided and an empty Properties
                          object is always used.
        :param v1_reason_codes: the MQTT v5.0 reason codes received from the broker for each
                          unsubscribe topic.  A list of ReasonCode instances OR a single
                          ReasonCode when we unsubscribe from a single topic.

        Decorator: @client.unsubscribe_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_unsubscribe.setter
    def on_unsubscribe(self, func: CallbackOnUnsubscribe | None) -> None:
        ...
    
    def unsubscribe_callback(self) -> Callable[[CallbackOnUnsubscribe], CallbackOnUnsubscribe]:
        ...
    
    @property
    def on_disconnect(self) -> CallbackOnDisconnect | None:
        """The callback called when the client disconnects from the broker.

        Expected signature for callback API version 2::

            disconnect_callback(client, userdata, disconnect_flags, reason_code, properties)

        Expected signature for callback API version 1 change with MQTT protocol version:
            * For MQTT v3.1 and v3.1.1 it's::

                disconnect_callback(client, userdata, rc)

            * For MQTT v5.0 it's::

                disconnect_callback(client, userdata, reason_code, properties)

        :param Client client: the client instance for this callback
        :param userdata:  the private user data as set in Client() or user_data_set()
        :param DisconnectFlag disconnect_flags: the flags for this disconnection.
        :param ReasonCode reason_code:  the disconnection reason code possibly received from the broker (see disconnect_flags).
                          In MQTT v5.0 it's the reason code defined by the standard.
                          In MQTT v3 it's never received from the broker, we convert an MQTTErrorCode,
                          see `convert_disconnect_error_code_to_reason_code()`.
                          `ReasonCode` may be compared to integer.
        :param Properties properties: the MQTT v5.0 properties received from the broker.
                          For MQTT v3.1 and v3.1.1 properties is not provided and an empty Properties
                          object is always used.
        :param int rc: the disconnection result
                          The rc parameter indicates the disconnection state. If
                          MQTT_ERR_SUCCESS (0), the callback was called in response to
                          a disconnect() call. If any other value the disconnection
                          was unexpected, such as might be caused by a network error.

        Decorator: @client.disconnect_callback() (``client`` is the name of the
            instance which this callback is being attached to)

        """
        ...
    
    @on_disconnect.setter
    def on_disconnect(self, func: CallbackOnDisconnect | None) -> None:
        ...
    
    def disconnect_callback(self) -> Callable[[CallbackOnDisconnect], CallbackOnDisconnect]:
        ...
    
    @property
    def on_socket_open(self) -> CallbackOnSocket | None:
        """The callback called just after the socket was opend.

        This should be used to register the socket to an external event loop for reading.

        Expected signature is (for all callback API version)::

            socket_open_callback(client, userdata, socket)

        :param Client client:     the client instance for this callback
        :param userdata:   the private user data as set in Client() or user_data_set()
        :param SocketLike sock: the socket which was just opened.

        Decorator: @client.socket_open_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_socket_open.setter
    def on_socket_open(self, func: CallbackOnSocket | None) -> None:
        ...
    
    def socket_open_callback(self) -> Callable[[CallbackOnSocket], CallbackOnSocket]:
        ...
    
    @property
    def on_socket_close(self) -> CallbackOnSocket | None:
        """The callback called just before the socket is closed.

        This should be used to unregister the socket from an external event loop for reading.

        Expected signature is (for all callback API version)::

            socket_close_callback(client, userdata, socket)

        :param Client client: the client instance for this callback
        :param userdata: the private user data as set in Client() or user_data_set()
        :param SocketLike sock: the socket which is about to be closed.

        Decorator: @client.socket_close_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_socket_close.setter
    def on_socket_close(self, func: CallbackOnSocket | None) -> None:
        ...
    
    def socket_close_callback(self) -> Callable[[CallbackOnSocket], CallbackOnSocket]:
        ...
    
    @property
    def on_socket_register_write(self) -> CallbackOnSocket | None:
        """The callback called when the socket needs writing but can't.

        This should be used to register the socket with an external event loop for writing.

        Expected signature is (for all callback API version)::

            socket_register_write_callback(client, userdata, socket)

        :param Client client: the client instance for this callback
        :param userdata: the private user data as set in Client() or user_data_set()
        :param SocketLike sock: the socket which should be registered for writing

        Decorator: @client.socket_register_write_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_socket_register_write.setter
    def on_socket_register_write(self, func: CallbackOnSocket | None) -> None:
        ...
    
    def socket_register_write_callback(self) -> Callable[[CallbackOnSocket], CallbackOnSocket]:
        ...
    
    @property
    def on_socket_unregister_write(self) -> CallbackOnSocket | None:
        """The callback called when the socket doesn't need writing anymore.

        This should be used to unregister the socket from an external event loop for writing.

        Expected signature is (for all callback API version)::

            socket_unregister_write_callback(client, userdata, socket)

        :param Client client: the client instance for this callback
        :param userdata: the private user data as set in Client() or user_data_set()
        :param SocketLike sock: the socket which should be unregistered for writing

        Decorator: @client.socket_unregister_write_callback() (``client`` is the name of the
            instance which this callback is being attached to)
        """
        ...
    
    @on_socket_unregister_write.setter
    def on_socket_unregister_write(self, func: CallbackOnSocket | None) -> None:
        ...
    
    def socket_unregister_write_callback(self) -> Callable[[CallbackOnSocket], CallbackOnSocket]:
        ...
    
    def message_callback_add(self, sub: str, callback: CallbackOnMessage) -> None:
        """Register a message callback for a specific topic.
        Messages that match 'sub' will be passed to 'callback'. Any
        non-matching messages will be passed to the default `on_message`
        callback.

        Call multiple times with different 'sub' to define multiple topic
        specific callbacks.

        Topic specific callbacks may be removed with
        `message_callback_remove()`.

        See `on_message` for the expected signature of the callback.

        Decorator: @client.topic_callback(sub) (``client`` is the name of the
            instance which this callback is being attached to)

        Example::

            @client.topic_callback("mytopic/#")
            def handle_mytopic(client, userdata, message):
                ...
        """
        ...
    
    def topic_callback(self, sub: str) -> Callable[[CallbackOnMessage], CallbackOnMessage]:
        ...
    
    def message_callback_remove(self, sub: str) -> None:
        """Remove a message callback previously registered with
        `message_callback_add()`."""
        ...
    
    def ack(self, mid: int, qos: int) -> MQTTErrorCode:
        """
           send an acknowledgement for a given message id (stored in :py:attr:`message.mid <MQTTMessage.mid>`).
           only useful in QoS>=1 and ``manual_ack=True`` (option of `Client`)
        """
        ...
    
    def manual_ack_set(self, on: bool) -> None:
        """
           The paho library normally acknowledges messages as soon as they are delivered to the caller.
           If manual_ack is turned on, then the caller MUST manually acknowledge every message once
           application processing is complete using `ack()`
        """
        ...
    


class _WebsocketWrapper:
    OPCODE_CONTINUATION = ...
    OPCODE_TEXT = ...
    OPCODE_BINARY = ...
    OPCODE_CONNCLOSE = ...
    OPCODE_PING = ...
    OPCODE_PONG = ...
    def __init__(self, socket: socket.socket | ssl.SSLSocket, host: str, port: int, is_ssl: bool, path: str, extra_headers: WebSocketHeaders | None) -> None:
        ...
    
    def __del__(self) -> None:
        ...
    
    def recv(self, length: int) -> bytes:
        ...
    
    def read(self, length: int) -> bytes:
        ...
    
    def send(self, data: bytes) -> int:
        ...
    
    def write(self, data: bytes) -> int:
        ...
    
    def close(self) -> None:
        ...
    
    def fileno(self) -> int:
        ...
    
    def pending(self) -> int:
        ...
    
    def setblocking(self, flag: bool) -> None:
        ...
    


